<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title>[es6]-02-块级作用域</title>
		<script src="./js/browser.js"></script>
		<script type="text/babel">
			/*
			 * 为什么需要块级作用域？
			 * ES5只有全局作用域和函数作用域，没有块级作用域，有很多不合理场景:
			 * 1.内层变量可能会覆盖外层变量。
			 */
			var tmp = new Date();
			function f(){
				console.log(tmp);
				if(false){
					var tmp = "hello world！";
				}
			}
			f();  //undefined 声明提升，后边的定义把前边的覆盖掉了。
			//第二种就是用来计数的循环变量泄漏为全局变量。典型的var定义的循环，上一篇有代码体现。
			
			/*
			 * let实际上为js新增了块级作用域。下面的代码两个代码块都声明了n，运行输出5，表示外层代码
			 * 不受内层代码块的影响。如果是var定义，就会收到影响，输出10；
			 */
			function f1(){
				let n = 5;
				if(true){
					let n = 10;
				}
				console.log(n);
			}
			f1();
			//es6允许块级作用域的任意嵌套：
			{{{{{ let insane = "hello world" }}}}}
			//上面代码使用了五层块级作用域，外部不能访问内部的变量。
			//块级作用域实际上使得广泛应用的立即执行匿名函数（IIFE）不再需要了。
			//IIFE写法
			(function(){
				
			})()
			//块级作用域写法
			{
				
			}
			/*
			 * 块级作用域与函数声明：
			 * ES5规定，函数只能在顶层作用域和函数作用域之中声明，不能在块作用域中声明，
			 *   情况一：
			 *   if(true){
			 * 	function(){}
			 * }
			 *   情况二：
			 *   try{
			 * 	  function(){}
			 * }
			 * 
			 *这两种情况，根据ES5的规定都是非法的。但是浏览器没有遵守这个规定，可以运行，在严格
			 * 模式下，还是会报错。
			 * ES6引入了块级作用域，明确允许在块级作用域中声明函数。
			 * 块级作用域中，函数声明语句的行为类似于let，在块级作用域之外，不可以引用。
			 * 因为块级作用域对作用域之外没有影响，这个差异会对老代码产生很大影响，为了减轻这个不兼容
			 * 问题，ES6在附录B中规定，浏览器可以不遵守上面的规定，有自己的行为方式。
			 *   1.允许在块级作用域内声明函数。
			 *   2.函数声明类似于var，即会提升到全局作用域或函数作用域的头部。
			 *   3.同时，函数声明还会提升到所在块级作用域的头部。
			 * 上面的3个规则只对ES6 的浏览器实现有效，其他环境的实现不用遵守，还是将块级作用域当做let处理。
			 * 
			 * 考虑到环境导致的行为差异太大，应该避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式。
			 * ES6的块级作用域允许声明函数的规则，只在使用大括号的情况下成立，没有使用大括号，会报错。
			 * 
			 */
			
		</script>
	</head>
	<body>
	</body>
</html>
